#include <limits.h>

#include "uav.h"

/*
 ******************************************************************************
 * DEFINES
 ******************************************************************************
 */
#define SYS_STATUS_3D_GYRO    ((uint32_t)1 << 0) /* for stub */
#define SYS_STATUS_3D_ACCEL   ((uint32_t)1 << 1) /* for stub */
#define SYS_STATUS_3D_MAG     ((uint32_t)1 << 2) /* for stub */
#define SYS_STATUS_ABS_PRES   ((uint32_t)1 << 3) /* for stub */
#define SYS_STATUS_DIFF_PRES  ((uint32_t)1 << 4) /* for stub */
#define SYS_STATUS_GPS        ((uint32_t)1 << 5) /* for stub */

#define TLM_REGISTRY_LEN (sizeof(Registy)/sizeof(tlm_registry_t))

/*
 ******************************************************************************
 * EXTERNS
 ******************************************************************************
 */
extern uint32_t GlobalFlags;
extern Mailbox tolink_mb;

extern mavlink_raw_pressure_t           mavlink_raw_pressure_struct;
extern mavlink_raw_imu_t                mavlink_raw_imu_struct;
extern mavlink_scaled_imu_t             mavlink_scaled_imu_struct;
extern mavlink_sys_status_t             mavlink_sys_status_struct;
extern mavlink_global_position_int_t    mavlink_global_position_int_struct;
extern mavlink_attitude_t               mavlink_attitude_struct;
extern mavlink_scaled_pressure_t        mavlink_scaled_pressure_struct;
extern mavlink_vfr_hud_t                mavlink_vfr_hud_struct; /* воздушная и земляная скорости */
extern mavlink_local_position_ned_t     mavlink_local_position_ned_struct;
extern mavlink_nav_controller_output_t  mavlink_nav_controller_output_struct;

/*
 ******************************************************************************
 * GLOBAL VARIABLES
 ******************************************************************************
 */
static Mail mail_raw_imu = {NULL, MAVLINK_MSG_ID_RAW_IMU, NULL};
static Mail mail_scaled_imu = {NULL, MAVLINK_MSG_ID_SCALED_IMU, NULL};
static Mail mail_raw_pressure = {NULL, MAVLINK_MSG_ID_RAW_PRESSURE, NULL};
static Mail mail_sys_status = {NULL, MAVLINK_MSG_ID_SYS_STATUS, NULL};
static Mail mail_global_position_int = {NULL, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, NULL};
static Mail mail_attitude = {NULL, MAVLINK_MSG_ID_ATTITUDE, NULL};
static Mail mail_scaled_pressure = {NULL, MAVLINK_MSG_ID_SCALED_PRESSURE, NULL};
static Mail mail_vfr_hud = {NULL, MAVLINK_MSG_ID_VFR_HUD, NULL};
static Mail mail_local_position_ned = {NULL, MAVLINK_MSG_ID_LOCAL_POSITION_NED, NULL};
static Mail mail_nav_controller_output = {NULL, MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT, NULL};

/*
 ******************************************************************************
 * PROTOTYPES
 ******************************************************************************
 */

/*
 *******************************************************************************
 *******************************************************************************
 * LOCAL FUNCTIONS
 *******************************************************************************
 *******************************************************************************
 */

/* autogenerated function */
static bool_t send_raw_imu(void){
  msg_t status = RDY_OK;
  mail_raw_imu.payload = &mavlink_raw_imu_struct;
  status = chMBPost(&tolink_mb, (msg_t)&mail_raw_imu, TIME_IMMEDIATE);
  if (status == RDY_OK)
    return TLM_SUCCESS;
  else
    return TLM_FAILED;
}

/* autogenerated function */
static bool_t send_scaled_imu(void){
  msg_t status = RDY_OK;
  mail_scaled_imu.payload = &mavlink_scaled_imu_struct;
  status = chMBPost(&tolink_mb, (msg_t)&mail_scaled_imu, TIME_IMMEDIATE);
  if (status == RDY_OK)
    return TLM_SUCCESS;
  else
    return TLM_FAILED;
}

/* autogenerated function */
static bool_t send_raw_pressure(void){
  msg_t status = RDY_OK;
  mail_raw_pressure.payload = &mavlink_raw_pressure_struct;
  status = chMBPost(&tolink_mb, (msg_t)&mail_raw_pressure, TIME_IMMEDIATE);
  if (status == RDY_OK)
    return TLM_SUCCESS;
  else
    return TLM_FAILED;
}

/* autogenerated function */
static bool_t send_sys_status(void){
  msg_t status = RDY_OK;
  mail_sys_status.payload = &mavlink_sys_status_struct;
  status = chMBPost(&tolink_mb, (msg_t)&mail_sys_status, TIME_IMMEDIATE);
  if (status == RDY_OK)
    return TLM_SUCCESS;
  else
    return TLM_FAILED;
}

/* autogenerated function */
static bool_t send_global_position_int(void){
  msg_t status = RDY_OK;
  mail_global_position_int.payload = &mavlink_global_position_int_struct;
  status = chMBPost(&tolink_mb, (msg_t)&mail_global_position_int, TIME_IMMEDIATE);
  if (status == RDY_OK)
    return TLM_SUCCESS;
  else
    return TLM_FAILED;
}

/* autogenerated function */
static bool_t send_attitude(void){
  msg_t status = RDY_OK;
  mail_attitude.payload = &mavlink_attitude_struct;
  status = chMBPost(&tolink_mb, (msg_t)&mail_attitude, TIME_IMMEDIATE);
  if (status == RDY_OK)
    return TLM_SUCCESS;
  else
    return TLM_FAILED;
}

/* autogenerated function */
static bool_t send_scaled_pressure(void){
  msg_t status = RDY_OK;
  mail_scaled_pressure.payload = &mavlink_scaled_pressure_struct;
  status = chMBPost(&tolink_mb, (msg_t)&mail_scaled_pressure, TIME_IMMEDIATE);
  if (status == RDY_OK)
    return TLM_SUCCESS;
  else
    return TLM_FAILED;
}

/* autogenerated function */
static bool_t send_vfr_hud(void){
  msg_t status = RDY_OK;
  mail_vfr_hud.payload = &mavlink_vfr_hud_struct;
  status = chMBPost(&tolink_mb, (msg_t)&mail_vfr_hud, TIME_IMMEDIATE);
  if (status == RDY_OK)
    return TLM_SUCCESS;
  else
    return TLM_FAILED;
}

/* autogenerated function */
static bool_t send_local_position_ned(void){
  msg_t status = RDY_OK;
  mail_local_position_ned.payload = &mavlink_local_position_ned_struct;
  status = chMBPost(&tolink_mb, (msg_t)&mail_local_position_ned, TIME_IMMEDIATE);
  if (status == RDY_OK)
    return TLM_SUCCESS;
  else
    return TLM_FAILED;
}

/* autogenerated function */
static bool_t send_nav_controller_output(void){
  msg_t status = RDY_OK;
  mail_nav_controller_output.payload = &mavlink_nav_controller_output_struct;
  status = chMBPost(&tolink_mb, (msg_t)&mail_nav_controller_output, TIME_IMMEDIATE);
  if (status == RDY_OK)
    return TLM_SUCCESS;
  else
    return TLM_FAILED;
}

/* autoinitialized array */
static tlm_registry_t Registy[] = {
    {11, NULL, send_raw_imu},
    {12, NULL, send_scaled_imu},
    {13, NULL, send_raw_pressure},
    {14, NULL, send_sys_status},
    {15, NULL, send_global_position_int},
    {16, NULL, send_attitude},
    {17, NULL, send_scaled_pressure},
    {18, NULL, send_vfr_hud},
    {19, NULL, send_local_position_ned},
    {20, NULL, send_nav_controller_output},
};


/**
 *
 */
static time_t get_sleep_time(void){
  time_t t;
  uint32_t i;

  t = Registy[0].next_dealine; /* just take first available */
  i = 0;
  while (i < TLM_REGISTRY_LEN){
    /* determine how much to sleep and refresh deadlines in structure */
    if (t > Registy[i].next_dealine)
      t = Registy[i].next_dealine;
    i++;
  }
  return t;
}

/**
 * refresh deadlines according sleeped time
 */
void refresh_deadlines(time_t t){
  uint32_t i = 0;
  while (i < TLM_REGISTRY_LEN){
    Registy[i].next_dealine -= t;
    if (Registy[i].next_dealine == 0){
      if (*(Registy[i].sleepperiod) != SEND_OFF){
        Registy[i].next_dealine = *(Registy[i].sleepperiod);
        if (GlobalFlags & TLM_LINK_FLAG)
          Registy[i].sender();
      }
      else
        Registy[i].next_dealine = 1200;
    }
    i++;
  }
}

/**
 * Update fields in mavlink structures that does not updates itself.
 */
void update_tlm_data(void){
  return;
}

/**
 *
 */
static WORKING_AREA(TlmSenderThreadWA, 128);
static msg_t TlmSenderThread(void *arg) {
  chRegSetThreadName("TLM_Sender");
  (void)arg;

  time_t t; /* milliseconds to sleep to next deadline */

  while TRUE{ /* main infinite cycle */
    t = get_sleep_time();
    chThdSleepMilliseconds(t);
    update_tlm_data();
    refresh_deadlines(t);
  }
  return 0;
}

/*
 *******************************************************************************
 * EXPORTED FUNCTIONS
 *******************************************************************************
 */

/**
 *
 */
void TlmSenderInit(void){
  Registy[0].sleepperiod = ValueSearch("T_raw_imu");
  Registy[1].sleepperiod = ValueSearch("T_scal_imu");
  Registy[2].sleepperiod = ValueSearch("T_raw_press");
  Registy[3].sleepperiod = ValueSearch("T_sys_status");
  Registy[4].sleepperiod = ValueSearch("T_gps_int");
  Registy[5].sleepperiod = ValueSearch("T_attitude");
  Registy[6].sleepperiod = ValueSearch("T_scal_press");
  Registy[7].sleepperiod = ValueSearch("T_vfr_hud");
  Registy[8].sleepperiod = ValueSearch("T_position_ned");
  Registy[9].sleepperiod = ValueSearch("T_nav_output");

  mavlink_sys_status_struct.onboard_control_sensors_present = (
              SYS_STATUS_3D_GYRO | SYS_STATUS_3D_ACCEL | SYS_STATUS_3D_MAG |
              SYS_STATUS_ABS_PRES | SYS_STATUS_DIFF_PRES | SYS_STATUS_GPS);
  mavlink_sys_status_struct.onboard_control_sensors_enabled = mavlink_sys_status_struct.onboard_control_sensors_present;
  mavlink_sys_status_struct.onboard_control_sensors_health  = mavlink_sys_status_struct.onboard_control_sensors_present;

  chThdCreateStatic(TlmSenderThreadWA,
          sizeof(TlmSenderThreadWA),
          LINK_THREADS_PRIO - 1,
          TlmSenderThread,
          NULL);
}





