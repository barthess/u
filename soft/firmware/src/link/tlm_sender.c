#include <limits.h>

#include "ch.h"
#include "hal.h"

#include "tlm_sender.h"
#include "param.h"
#include "message.h"
#include "main.h"
#include "sanity.h"
#include "timekeeping.h"

/*
 ******************************************************************************
 * DEFINES
 ******************************************************************************
 */
#define SYS_STATUS_3D_GYRO    ((uint32_t)1 << 0) /* for stub */
#define SYS_STATUS_3D_ACCEL   ((uint32_t)1 << 1) /* for stub */
#define SYS_STATUS_3D_MAG     ((uint32_t)1 << 2) /* for stub */
#define SYS_STATUS_ABS_PRES   ((uint32_t)1 << 3) /* for stub */
#define SYS_STATUS_DIFF_PRES  ((uint32_t)1 << 4) /* for stub */
#define SYS_STATUS_GPS        ((uint32_t)1 << 5) /* for stub */

#define TLM_REGISTRY_LEN (sizeof(Registy)/sizeof(tlm_registry_t))

/*
 ******************************************************************************
 * EXTERNS
 ******************************************************************************
 */
extern Mailbox tolink_mb;
extern EventSource init_event;

extern mavlink_raw_pressure_t        mavlink_raw_pressure_struct;
extern mavlink_raw_imu_t             mavlink_raw_imu_struct;
extern mavlink_scaled_imu_t          mavlink_scaled_imu_struct;
extern mavlink_sys_status_t          mavlink_sys_status_struct;
extern mavlink_global_position_int_t mavlink_global_position_int_struct;
extern mavlink_attitude_t            mavlink_attitude_struct;
extern mavlink_scaled_pressure_t     mavlink_scaled_pressure_struct;
extern mavlink_vfr_hud_t             mavlink_vfr_hud_struct; /* воздушная и земляная скорости */

/*
 ******************************************************************************
 * GLOBAL VARIABLES
 ******************************************************************************
 */
static Mail mail_raw_imu = {NULL, MAVLINK_MSG_ID_RAW_IMU, NULL};
static Mail mail_scaled_imu = {NULL, MAVLINK_MSG_ID_SCALED_IMU, NULL};
static Mail mail_raw_pressure = {NULL, MAVLINK_MSG_ID_RAW_PRESSURE, NULL};
static Mail mail_sys_status = {NULL, MAVLINK_MSG_ID_SYS_STATUS, NULL};
static Mail mail_global_position_int = {NULL, MAVLINK_MSG_ID_GLOBAL_POSITION_INT, NULL};
static Mail mail_attitude = {NULL, MAVLINK_MSG_ID_ATTITUDE, NULL};
static Mail mail_scaled_pressure = {NULL, MAVLINK_MSG_ID_SCALED_PRESSURE, NULL};
static Mail mail_vfr_hud = {NULL, MAVLINK_MSG_ID_VFR_HUD, NULL};

/*
 ******************************************************************************
 * PROTOTYPES
 ******************************************************************************
 */

/*
 *******************************************************************************
 *******************************************************************************
 * LOCAL FUNCTIONS
 *******************************************************************************
 *******************************************************************************
 */

/* autogenerated function */
static bool_t send_raw_imu(void){
  msg_t status = RDY_OK;
    if (mail_raw_imu.payload == NULL){
      mail_raw_imu.payload = &mavlink_raw_imu_struct;
      status = chMBPost(&tolink_mb, (msg_t)&mail_raw_imu, TIME_IMMEDIATE);
      if (status == RDY_OK) {return TLM_SUCCESS;}
      else {return TLM_FAILED;}
    }
    else {return TLM_FAILED;}
  }

/* autogenerated function */
static bool_t send_scaled_imu(void){
  msg_t status = RDY_OK;
    if (mail_scaled_imu.payload == NULL){
      mail_scaled_imu.payload = &mavlink_scaled_imu_struct;
      status = chMBPost(&tolink_mb, (msg_t)&mail_scaled_imu, TIME_IMMEDIATE);
      if (status == RDY_OK) {return TLM_SUCCESS;}
      else {return TLM_FAILED;}
    }
    else {return TLM_FAILED;}
  }

/* autogenerated function */
static bool_t send_raw_pressure(void){
  msg_t status = RDY_OK;
    if (mail_raw_pressure.payload == NULL){
      mail_raw_pressure.payload = &mavlink_raw_pressure_struct;
      status = chMBPost(&tolink_mb, (msg_t)&mail_raw_pressure, TIME_IMMEDIATE);
      if (status == RDY_OK) {return TLM_SUCCESS;}
      else {return TLM_FAILED;}
    }
    else {return TLM_FAILED;}
  }

/* autogenerated function */
static bool_t send_sys_status(void){
  msg_t status = RDY_OK;
    if (mail_sys_status.payload == NULL){
      mail_sys_status.payload = &mavlink_sys_status_struct;
      status = chMBPost(&tolink_mb, (msg_t)&mail_sys_status, TIME_IMMEDIATE);
      if (status == RDY_OK) {return TLM_SUCCESS;}
      else {return TLM_FAILED;}
    }
    else {return TLM_FAILED;}
  }

/* autogenerated function */
static bool_t send_global_position_int(void){
  msg_t status = RDY_OK;
    if (mail_global_position_int.payload == NULL){
      mail_global_position_int.payload = &mavlink_global_position_int_struct;
      status = chMBPost(&tolink_mb, (msg_t)&mail_global_position_int, TIME_IMMEDIATE);
      if (status == RDY_OK) {return TLM_SUCCESS;}
      else {return TLM_FAILED;}
    }
    else {return TLM_FAILED;}
  }

/* autogenerated function */
static bool_t send_attitude(void){
  msg_t status = RDY_OK;
    if (mail_attitude.payload == NULL){
      mail_attitude.payload = &mavlink_attitude_struct;
      status = chMBPost(&tolink_mb, (msg_t)&mail_attitude, TIME_IMMEDIATE);
      if (status == RDY_OK) {return TLM_SUCCESS;}
      else {return TLM_FAILED;}
    }
    else {return TLM_FAILED;}
  }

/* autogenerated function */
static bool_t send_scaled_pressure(void){
  msg_t status = RDY_OK;
    if (mail_scaled_pressure.payload == NULL){
      mail_scaled_pressure.payload = &mavlink_scaled_pressure_struct;
      status = chMBPost(&tolink_mb, (msg_t)&mail_scaled_pressure, TIME_IMMEDIATE);
      if (status == RDY_OK) {return TLM_SUCCESS;}
      else {return TLM_FAILED;}
    }
    else {return TLM_FAILED;}
  }

/* autogenerated function */
static bool_t send_vfr_hud(void){
  msg_t status = RDY_OK;
    if (mail_vfr_hud.payload == NULL){
      mail_vfr_hud.payload = &mavlink_vfr_hud_struct;
      status = chMBPost(&tolink_mb, (msg_t)&mail_vfr_hud, TIME_IMMEDIATE);
      if (status == RDY_OK) {return TLM_SUCCESS;}
      else {return TLM_FAILED;}
    }
    else {return TLM_FAILED;}
  }

/* autoarray */
static tlm_registry_t Registy[] = {
    {11, NULL, send_raw_imu},
    {12, NULL, send_scaled_imu},
    {13, NULL, send_raw_pressure},
    {14, NULL, send_sys_status},
    {15, NULL, send_global_position_int},
    {16, NULL, send_attitude},
    {17, NULL, send_scaled_pressure},
    {18, NULL, send_vfr_hud},
};

/**
 *
 */
static time_t get_sleep_time(void){
  time_t t;
  uint32_t i;

  t = Registy[0].next_dealine; /* just take first available */
  i = 0;
  while (i < TLM_REGISTRY_LEN){
    /* determine how much to sleep and refresh deadlines in structure */
    if (t > Registy[i].next_dealine)
      t = Registy[i].next_dealine;
    i++;
  }
  return t;
}

/**
 * refresh deadlines according sleeped time
 */
void refresh_deadlines(time_t t){
  uint32_t i = 0;
  while (i < TLM_REGISTRY_LEN){
    Registy[i].next_dealine -= t;
    if (Registy[i].next_dealine == 0){
      if (*(Registy[i].sleepperiod) != SEND_OFF){
        Registy[i].next_dealine = *(Registy[i].sleepperiod);
        Registy[i].sender();
      }
      else
        Registy[i].next_dealine = 1200;
    }
    i++;
  }
}

/**
 *
 */
static WORKING_AREA(TlmSenderThreadWA, 128);
static msg_t TlmSenderThread(void *arg) {
  chRegSetThreadName("TLM_Sender");
  (void)arg;

  EventListener self_el;
  chEvtRegister(&init_event, &self_el, MODEM_READY_EVID);
  chEvtWaitOne(EVENT_MASK(MODEM_READY_EVID));

  time_t t; /* milliseconds to sleep to next deadline */

  while TRUE{ /* main infinite cycle */
    t = get_sleep_time();
    chThdSleepMilliseconds(t);
    refresh_deadlines(t);
  }
  return 0;
}



/*
 *******************************************************************************
 * EXPORTED FUNCTIONS
 *******************************************************************************
 */

/**
 *
 */
void TlmSenderInit(void){
  Registy[0].sleepperiod = ValueSearch("T_raw_imu");
  Registy[1].sleepperiod = ValueSearch("T_scal_imu");
  Registy[2].sleepperiod = ValueSearch("T_raw_press");
  Registy[3].sleepperiod = ValueSearch("T_sys_status");
  Registy[4].sleepperiod = ValueSearch("T_gps_int");
  Registy[5].sleepperiod = ValueSearch("T_attitude");
  Registy[6].sleepperiod = ValueSearch("T_scal_press");
  Registy[7].sleepperiod = ValueSearch("T_vfr_hud");

  mavlink_sys_status_struct.onboard_control_sensors_present = (
              SYS_STATUS_3D_GYRO | SYS_STATUS_3D_ACCEL | SYS_STATUS_3D_MAG |
              SYS_STATUS_ABS_PRES | SYS_STATUS_DIFF_PRES | SYS_STATUS_GPS);
  mavlink_sys_status_struct.onboard_control_sensors_enabled = mavlink_sys_status_struct.onboard_control_sensors_present;
  mavlink_sys_status_struct.onboard_control_sensors_health  = mavlink_sys_status_struct.onboard_control_sensors_present;

  chThdCreateStatic(TlmSenderThreadWA,
          sizeof(TlmSenderThreadWA),
          LINK_THREADS_PRIO - 1,
          TlmSenderThread,
          NULL);
}





