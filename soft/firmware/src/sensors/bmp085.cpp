#include <math.h>

#include "uav.h"
#include "bmp085.hpp"
#include "message.hpp"
#include "sensors.hpp"
#include "param_registry.hpp"
#include "dsp.hpp"

#include "bmp085_tab_autogenerated.h"

/*
 ******************************************************************************
 * DEFINES
 ******************************************************************************
 */

// sensor precision (see datasheet)
#define OSS 3 // 3 -- max

#define TEMP_DECIMATOR  0x1F      /* decimation value for temperature measurements */
#define PRESS_READ_TMO  MS2ST(50) /* wait pressure results (datasheet says 25.5 ms) */
#define TEMP_READ_TMO   MS2ST(10) /* wait temperature results (datasheet says 4.5 ms) */

/*
 ******************************************************************************
 * EXTERNS
 ******************************************************************************
 */
extern RawData raw_data;
extern CompensatedData comp_data;
extern ParamRegistry param_registry;

extern mavlink_vfr_hud_t          mavlink_out_vfr_hud_struct;
extern mavlink_scaled_pressure_t  mavlink_out_scaled_pressure_struct;

/*
 ******************************************************************************
 * GLOBAL VARIABLES
 ******************************************************************************
 */
/**/
static alphabeta_instance_float bmp085_filter;
static alphabeta_instance_float bmp085_climb_filter;

/* value to calculate time between measurements and climb rate */
static systime_t measurement_time_prev;
static systime_t measurement_time;

static float altitude = 0;
static float altitude_prev = 0;
static float climb = 0;

/*
 *******************************************************************************
 *******************************************************************************
 * LOCAL FUNCTIONS
 *******************************************************************************
 *******************************************************************************
 */
/**
 * Calculate height in meters using proved formulae
 */
static float press_to_height_f32(uint32_t pval){
  const float p0 = 101325.0f;
  return 44330.0f * (1.0f - powf((float)pval/p0, 1.0f/5.255f));
}

/**
 * Calculate compensated pressure value using black magic from datasheet.
 *
 * @ut[in]    uncompensated temperature value.
 * @ut[in]    uncompensated pressure value.
 *
 * @return    compensated pressure in Pascals.
 */
uint32_t BMP085::bmp085_calc_pressure(uint32_t ut, uint32_t up){
  // compensated temperature and pressure values
  uint32_t pval = 0;
  int32_t  tval = 0;

  int32_t  x1, x2, x3, b3, b5, b6, p;
  uint32_t  b4, b7;

  x1 = (ut - ac6) * ac5 >> 15;
  x2 = ((int32_t) mc << 11) / (x1 + md);
  b5 = x1 + x2;
  tval = (b5 + 8) >> 4;

  b6 = b5 - 4000;
  x1 = (b2 * (b6 * b6 >> 12)) >> 11;
  x2 = ac2 * b6 >> 11;
  x3 = x1 + x2;
  b3 = ((((int32_t)ac1 * 4 + x3) << OSS) + 2) >> 2;

  x1 = ac3 * b6 >> 13;
  x2 = (b1 * (b6 * b6 >> 12)) >> 16;
  x3 = ((x1 + x2) + 2) >> 2;
  b4 = (ac4 * (uint32_t)(x3 + 32768)) >> 15;
  b7 = ((uint32_t)up - b3) * (50000 >> OSS);
  if(b7 < 0x80000000)
    p = (b7 * 2) / b4;
  else
    p = (b7 / b4) * 2;

  x1 = (p >> 8) * (p >> 8);
  x1 = (x1 * 3038) >> 16;
  x2 = (-7357L * p) >> 16;
  pval = p + ((x1 + x2 + 3791) >> 4);

  raw_data.temp_bmp085 = (int16_t)tval;
  return pval;
}

/**
 * Calculate height and climb from pressure value
 * @pval[in]    pressure in Pascals.
 */
void BMP085::process_pressure(uint32_t pval){

  (void)press_to_height_tab(pval);
  altitude = press_to_height_f32(pval);

//  altitude = press_to_height_tab(pval);
//  (void)press_to_height_f32(pval);

  comp_data.baro_altitude = alphabeta_float(&bmp085_filter, altitude, *flen_pres_stat);

  measurement_time = chTimeNow();
  climb = (comp_data.baro_altitude - altitude_prev) * (float)(CH_FREQUENCY / (measurement_time - measurement_time_prev));
  measurement_time_prev = measurement_time;
  altitude_prev = comp_data.baro_altitude;

  comp_data.baro_climb = alphabeta_float(&bmp085_climb_filter, climb, *flen_climb);

  mavlink_out_vfr_hud_struct.alt = comp_data.baro_altitude;
  mavlink_out_vfr_hud_struct.climb = comp_data.baro_climb;
  mavlink_out_vfr_hud_struct.alt = comp_data.baro_altitude;
  mavlink_out_scaled_pressure_struct.press_abs = (float)pval / 100.0f;
}

/*
 *******************************************************************************
 * EXPORTED FUNCTIONS
 *******************************************************************************
 */
/**
 *
 */
BMP085::BMP085(I2CDriver* i2cdp, i2caddr_t addr):
I2CSensor(i2cdp, addr)
{
  measure = MEASURE_NONE;
  up  = 0; ut  = 0;
  ac1 = 0; ac2 = 0; ac3 = 0; b1 = 0; b2 = 0; mb = 0; mc = 0; md = 0;
  ac4 = 0; ac5 = 0; ac6 = 0;
  ready = false;
}

/**
 *
 */
void BMP085::update(float *result, size_t len){
  (void)result;
  (void)len;

  chDbgCheck((true == ready), "you must start() this device");

  switch(measure){
  case MEASURE_NONE:
    /* start temerature measurement */
    txbuf[0] = BOSCH_CTL;
    txbuf[1] = BOSCH_TEMP;
    transmit(txbuf, 2, rxbuf, 0);
    measure = MEASURE_T;
    break;

  case MEASURE_T:
    /* acquire temperature measurement */
    txbuf[0] = BOSCH_ADC_MSB;
    transmit(txbuf, 1, rxbuf, 2);
    ut = (rxbuf[0] << 8) + rxbuf[1];

    /* fire up pressure measurement */
    txbuf[0] = BOSCH_CTL;
    txbuf[1] = (0x34 + (OSS<<6));
    transmit(txbuf, 2, rxbuf, 0);
    measure = MEASURE_P;
    break;

  case MEASURE_P:
    /* acqure pressure value */
    txbuf[0] = BOSCH_ADC_MSB;
    transmit(txbuf, 1, rxbuf, 3);
    up = ((rxbuf[0] << 16) + (rxbuf[1] << 8) + rxbuf[2]) >> (8 - OSS);

    /* start temerature measurement */
    txbuf[0] = BOSCH_CTL;
    txbuf[1] = BOSCH_TEMP;
    transmit(txbuf, 2, rxbuf, 0);
    measure = MEASURE_T;
    break;

  default:
    chDbgPanic("unhanlded case");
    break;
  }

  this->pickle();
}

/**
 *
 */
void BMP085::start(void) {
  if (need_full_init())
    hw_init_full();
  else
    hw_init_fast();

  flen_pres_stat = (const uint32_t*)param_registry.valueSearch("FLEN_pres_stat");
  flen_climb     = (const uint32_t*)param_registry.valueSearch("FLEN_climb");
  ready = true;
}

/**
 *
 */
void BMP085::stop(void) {
  measure = MEASURE_NONE;
  ready = false;
}

/**
 *
 */
void BMP085::pickle(void) {
  raw_data.pressure_static = bmp085_calc_pressure(ut, up);
  process_pressure(raw_data.pressure_static);
}

/**
 *
 */
void BMP085::hw_init_full(void) {
  /* get calibration coefficients from sensor */
  txbuf[0] = 0xAA;
  transmit(txbuf, 1, rxbuf, 22);

  ac1 = (rxbuf[0]  << 8) + rxbuf[1];
  ac2 = (rxbuf[2]  << 8) + rxbuf[3];
  ac3 = (rxbuf[4]  << 8) + rxbuf[5];
  ac4 = (rxbuf[6]  << 8) + rxbuf[7];
  ac5 = (rxbuf[8]  << 8) + rxbuf[9];
  ac6 = (rxbuf[10] << 8) + rxbuf[11];
  b1  = (rxbuf[12] << 8) + rxbuf[13];
  b2  = (rxbuf[14] << 8) + rxbuf[15];
  mb  = (rxbuf[16] << 8) + rxbuf[17];
  mc  = (rxbuf[18] << 8) + rxbuf[19];
  md  = (rxbuf[20] << 8) + rxbuf[21];
}

/**
 *
 */
void BMP085::hw_init_fast(void) {
  this->hw_init_full();
}

